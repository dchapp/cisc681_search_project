\documentclass[12pt, conference, compsocconf]{IEEEtran}

\usepackage{amsmath, amsfonts}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tikz}

%%% Package and definitions for displaying pseudocode
\usepackage[noend]{algpseudocode}
\newcommand*\Let[2]{\State #1 $\gets$ #2}
\algrenewcommand\alglinenumber[1]{
    {\sf\footnotesize\addfontfeatures{Colour=888888,Numbers=Monospaced}#1}}
\algrenewcommand\algorithmicrequire{\textbf{Precondition:}}
\algrenewcommand\algorithmicensure{\textbf{Postcondition:}}


\begin{document}
\title{CISC-481/681 Project 2: A* Search with Heuristics}

\author{\IEEEauthorblockN{Dylan Chapp, Michael Wyatt} \IEEEauthorblockA{Department of Computer and Information Sciences \\ University of Delaware - Newark, DE 19716 \\ Email: \{dchapp\}, \{mwyatt\}@udel.edu}}

\maketitle

\section{Introduction}
In this work we implement the A* search algorithm to solve the problem of directing a predator (e.g., a cat) through a maze of obstacles to multiple prey objectives (e.g., mice). 
We introduce heuristics specifically tailored to this multi-objective pathfinding problem and provide an empirical evaluation of their performance. 
Dylan

\section{Related Work}
Mike

\subsection{Problem Characterization}
We are presented with the problem of providing a cat with a shortest path that allows it to navigate to and consume $m$ mice on an $n \times n$ board of tiles. 
However, some of these tiles are obstacles that the cat cannot traverse, which makes computing shortest paths nontrivial.
We employ the A* search algorithm to find, for a fixed starting tile and a fixed goal tile containing a mouse, a shortest path for the cat. 
In turn, we use heuristics for executing repeated applications of single-objective A* search to find a shortest path to all of the mice. 

\section{The A* Algorithm}
A* is an informed search algorithm used for finding the shortest path from a single node in a graph--the start--to some other node in the graph--the goal. 
Specifically, A* constructs a tree whose root is the start node and one of which's leaves is the goal node. 

The A* algorithm bears resemblance to uninformed search algorithms such as breadth-first search in terms of its general structure, but differs in that it maintains a priority queue of nodes to expand upon rather than a FIFO/LIFO queue. 
The priority queue is ordered according to a heuristic that accounts for both the known cost to reach a node from the starting node and the estimated cost to reach the goal node from that node. 

In fact, A* was developed as an improved upon Dijkstra's algorithm, a similiar search algorithm that too maintains a priority queue of nodes, but orders them only with respect to the known cost to reach them from the starting node. 
Below, we provide pseudocode for A* highlighting the difference.

%\begin{algorithm}
%    \caption{A* Search}
%    \label{alg-astar}
%    \begin{algorithmic}[1]
%        \Statex
%        \Function{A*}{start, goal} 
%            \Let{explored}{\{\}}
%            \Let{frontier}{\{\}}
%            \While{}
%            
%            \EndWhile
%        \State \Return{0}
%        \EndFunction
%    \end{algorithmic}
%\end{algorithm}
            
            

\subsection{Single Objective A* Heuristics}
Mke

\subsection{Multi Objective A* Heuristics}
Mike

\section{Implementation}
We implemented our core single-objective A* search algorithm, all helper functions for ingesting and reporting data, and all functions necessary to adapt the single-objective algorithm to the multi-objective problem posed in Python. 
This choice was guided by the authors' familiarity with the language and the knowledge that we would be able to rapidly iterate on and test our design.
With the exception of a few uses of the NumPy numerical computation module for convenience, the project is implemented without the use of 3rd-party modules. 

\subsection{Components}
Our implementation is composed of three primary components: board generation, the core single-objective solver and its heuristics, and a top-level driver program that invokes the single-objective solver according to its own set of heuristics to solve multi-objective boards. 

In addition to the board specified in the project description, our implementation can read in an arbitrary board from a file or generate a broader class of randomized board from user-specified parameters. 
The initial impetus for providing a more flexible board-generation procedure than that specified in the project description was to explore the effect of the distribution of obstacles on the board on runtime for a fixed board size.

\subsection{Use}
To use our implementation, first ensure that all dependencies are met as per the README available at \url{https://github.com/dchapp/cisc681_search_project} and then invoke the \texttt{Driver.py} program. 
By default, the program will generate and solve a $20 \times 20$ board conforming to the problem statement's obstacle and objective frequencies.
Also by default, the program will use a fixed choice of heuristic.
However, the size of board, board-generation procedure, and choice of heuristic can all be given as arguments to the \texttt{Driver.py} program. 

\section{Evaluation}
There are two factors upon which we judge the quality of our implementation: runtime performance and optimality of the generated path.  

\subsection{Runtime Performance}
Each combination of a single-objective heuristic and a multiobjective heuristic--e.g., the Manhattan distance single-objective heuristic and the nearest-neighbor multi-objective heuristic--is ran multiple times on boards of increasing size for a fixed number of objectives.
In initial testing we observed large variation in runtime due to differences in obstacle layout on the randomly generated boards. 
Consequently, we report the mean and standard deviation of the runtimes for each heuristic combination. 

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.45\textwidth]{runtimes.png}
    \caption{Mean of runtimes for variable-width boards with a fixed number of objectives}
    \label{runtimes-fig}
\end{figure}

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.45\textwidth]{variability.png}
    \caption{Standard deviation of runtimes for variable-width boards with a fixed number of objectives}
    \label{variability-fig}
\end{figure}

\subsection{Optimality}
Mike

\section{Future Work}
Mike

\section{Conclusion}
Dylan

\bibliographystyle{IEEEtran}
\bibliography{bibliography}

\end{document}
